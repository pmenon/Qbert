package net.qbert.protocol

import net.qbert.channel.{ ChannelManager }
import net.qbert.connection.AMQConnection
import net.qbert.framing.{AMQDataBlock, Frame, AMQP, FramePayload, ProtocolInitiation, Method, FieldTable, AMQLongString}
import net.qbert.handler.StateAwareMethodHandler
import net.qbert.logging.Logging
import net.qbert.state.{State, StateManager}

trait AMQProtocolSession {
  val conn: AMQConnection
  var protocolVersion: Option[ProtocolVersion] = None

  def writeFrame(frame: Frame) = conn writeFrame frame
}

class AMQProtocolDriver(val conn: AMQConnection) extends AMQProtocolSession with ChannelManager with Logging {

  val stateManager = new StateManager
  val methodHandler = new StateAwareMethodHandler(this)

  def dataBlockReceived(datablock: AMQDataBlock) = {
    datablock match {
      case pi: ProtocolInitiation => protocolInitiation(pi)
      case frame: Frame => frame.typeId match {
        case Frame.FRAME_METHOD => methodReceived(frame.channelId, frame.payload)
        case Frame.FRAME_CONTENT => contentHeaderReceived(frame.channelId, frame.payload)
        case Frame.FRAME_BODY => contentBodyReceived(frame.channelId, frame.payload)
        case Frame.FRAME_HEARTBEAT => heartbeatReceived(frame)
      }
    }
  }

  def versionOk(major: Int, minor: Int) = true

  def protocolInitiation(pi: ProtocolInitiation) = {
    if(stateManager notInState State.waitingConnection) error("incorrect order")

    info("Protocol Initiation Received ..." + pi)
    
    val response = if (versionOk(pi.major, pi.minor)) {
      val method = AMQP.Connection.Start(0, 9, FieldTable(), AMQLongString("AMQPPLAIN"), AMQLongString("en_US"))
      method.generateFrame(0)
    } else {
      ProtocolInitiation(ProtocolInitiation.AMQP_HEADER, 1, 1, 0, 9)
    }
    
    conn writeFrame response

    stateManager nextNaturalState
  }

  def methodReceived(channelId: Int, payload: FramePayload) = {
    info("Method received ... " + payload)
    methodHandler handleMethod (channelId, payload)
  }

  def contentHeaderReceived(channelId: Int, payload: FramePayload) = {} 
  def contentBodyReceived(channelId: Int, payload: FramePayload) = {}
  def heartbeatReceived(f: Frame) = {}

}
